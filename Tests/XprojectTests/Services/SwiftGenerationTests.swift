//
// SwiftGenerationTests.swift
// Xproject
//

import Foundation
import Testing
@testable import Xproject

struct SwiftGenerationTests {
    // MARK: - Template Tests

    @Test("Base class template generates correct Swift code")
    func testBaseClassTemplate() throws {
        let properties = [
            SwiftProperty(name: "apiURL", type: .url, value: "https://api.example.com"),
            SwiftProperty(name: "environmentName", type: .string, value: "development"),
            SwiftProperty(name: "debugMode", type: .bool, value: "true"),
            SwiftProperty(name: "maxRetries", type: .int, value: "3")
        ]

        let output = SwiftTemplates.generateBaseClass(properties: properties, environmentName: "dev")

        #expect(output.contains("public final class EnvironmentService"))
        #expect(output.contains("public init() {}"))
        #expect(output.contains("public let apiURL = url(\"https://api.example.com\")"))
        #expect(output.contains("public let debugMode = true"))
        #expect(output.contains("public let environmentName = \"development\""))
        #expect(output.contains("public let maxRetries = 3"))
        #expect(output.contains("Generated by xp env load dev"))
        #expect(output.contains("private func url(_ urlString: String) -> URL"))
    }

    @Test("Extension template generates correct Swift code")
    func testExtensionTemplate() throws {
        let properties = [
            SwiftProperty(name: "bundleIdentifier", type: .string, value: "com.example.app"),
            SwiftProperty(name: "displayName", type: .string, value: "MyApp")
        ]

        let output = SwiftTemplates.generateExtension(properties: properties, environmentName: "production")

        #expect(output.contains("extension EnvironmentService"))
        #expect(output.contains("public var bundleIdentifier: String { \"com.example.app\" }"))
        #expect(output.contains("public var displayName: String { \"MyApp\" }"))
        #expect(output.contains("Generated by xp env load production"))
    }

    @Test("Extension template includes URL helper only when needed")
    func testExtensionURLHelper() throws {
        let propertiesWithURL = [
            SwiftProperty(name: "apiURL", type: .url, value: "https://api.example.com")
        ]
        let outputWithURL = SwiftTemplates.generateExtension(properties: propertiesWithURL, environmentName: "dev")
        #expect(outputWithURL.contains("private func url"))

        let propertiesWithoutURL = [
            SwiftProperty(name: "name", type: .string, value: "test")
        ]
        let outputWithoutURL = SwiftTemplates.generateExtension(properties: propertiesWithoutURL, environmentName: "dev")
        #expect(!outputWithoutURL.contains("private func url"))
    }

    @Test("Base class template generates additional imports")
    func testBaseClassWithImports() throws {
        let properties = [
            SwiftProperty(name: "name", type: .string, value: "test")
        ]

        let output = SwiftTemplates.generateBaseClass(
            properties: properties,
            environmentName: "dev",
            imports: ["ModuleA", "ModuleB"]
        )

        #expect(output.contains("import Foundation"))
        #expect(output.contains("import ModuleA"))
        #expect(output.contains("import ModuleB"))
        // Verify imports are sorted alphabetically
        let foundationIndex = output.range(of: "import Foundation")!.lowerBound
        let moduleAIndex = output.range(of: "import ModuleA")!.lowerBound
        let moduleBIndex = output.range(of: "import ModuleB")!.lowerBound
        #expect(foundationIndex < moduleAIndex)
        #expect(moduleAIndex < moduleBIndex)
    }

    @Test("Extension template generates additional imports")
    func testExtensionWithImports() throws {
        let properties = [
            SwiftProperty(name: "bundleIdentifier", type: .string, value: "com.example.app")
        ]

        let output = SwiftTemplates.generateExtension(
            properties: properties,
            environmentName: "dev",
            imports: ["CoreModule"]
        )

        #expect(output.contains("import Foundation"))
        #expect(output.contains("import CoreModule"))
        #expect(output.contains("extension EnvironmentService"))
    }

    @Test("Templates without imports only include Foundation")
    func testTemplatesWithoutImports() throws {
        let properties = [
            SwiftProperty(name: "name", type: .string, value: "test")
        ]

        let baseOutput = SwiftTemplates.generateBaseClass(
            properties: properties,
            environmentName: "dev"
        )
        let extensionOutput = SwiftTemplates.generateExtension(
            properties: properties,
            environmentName: "dev"
        )

        // Both should contain Foundation but no other imports
        #expect(baseOutput.contains("import Foundation"))
        #expect(extensionOutput.contains("import Foundation"))

        // Count "import " occurrences - should be exactly 1
        let baseImportCount = baseOutput.components(separatedBy: "import ").count - 1
        let extensionImportCount = extensionOutput.components(separatedBy: "import ").count - 1
        #expect(baseImportCount == 1)
        #expect(extensionImportCount == 1)
    }

    @Test("Templates filter empty strings and duplicates from imports")
    func testTemplatesFilterInvalidImports() throws {
        let properties = [
            SwiftProperty(name: "name", type: .string, value: "test")
        ]

        let output = SwiftTemplates.generateBaseClass(
            properties: properties,
            environmentName: "dev",
            imports: ["ModuleA", "", "ModuleA", "ModuleB", ""]
        )

        // Should contain Foundation and both modules (deduplicated)
        #expect(output.contains("import Foundation"))
        #expect(output.contains("import ModuleA"))
        #expect(output.contains("import ModuleB"))

        // Should NOT contain empty import
        #expect(!output.contains("import \n"))
        #expect(!output.contains("import\n"))

        // Count imports - should be exactly 3 (Foundation, ModuleA, ModuleB)
        let importCount = output.components(separatedBy: "import ").count - 1
        #expect(importCount == 3)
    }

    @Test("Templates reject malicious module names with code injection")
    func testTemplatesRejectCodeInjection() throws {
        let properties = [
            SwiftProperty(name: "name", type: .string, value: "test")
        ]

        // Attempt various code injection attacks
        let maliciousImports = [
            "Foundation\nimport UIKit",           // Newline injection
            "UIKit\n\nclass Malicious {}",        // Code injection via newline
            "Module-Name",                         // Invalid character (hyphen)
            "Module.Submodule",                    // Invalid character (dot)
            "123Module",                           // Starts with digit
            "Module Name",                         // Space in name
            "Module;print(\"hacked\")",           // Semicolon injection
            "_ValidModule",                        // Valid: starts with underscore
            "Valid_Module_123"                     // Valid: underscores and digits
        ]

        let output = SwiftTemplates.generateBaseClass(
            properties: properties,
            environmentName: "dev",
            imports: maliciousImports
        )

        // Should only contain valid modules
        #expect(output.contains("import Foundation"))
        #expect(output.contains("import Valid_Module_123"))
        #expect(output.contains("import _ValidModule"))

        // Should NOT contain any malicious content
        #expect(!output.contains("UIKit"))
        #expect(!output.contains("Malicious"))
        #expect(!output.contains("hacked"))
        #expect(!output.contains("Module-Name"))
        #expect(!output.contains("Module.Submodule"))
        #expect(!output.contains("123Module"))

        // Count imports - should be exactly 3 (Foundation + 2 valid modules)
        let importCount = output.components(separatedBy: "import ").count - 1
        #expect(importCount == 3)
    }

    // MARK: - CamelCase Conversion Tests

    @Test("CamelCase conversion works correctly")
    func testCamelCaseConversion() throws {
        let helper = TestHelper()

        let result1 = helper.convertToCamelCase("api_url", prefix: "")
        #expect(result1 == "apiURL")

        let result2 = helper.convertToCamelCase("bundle_identifier", prefix: "")
        #expect(result2 == "bundleIdentifier")

        let result3 = helper.convertToCamelCase("auth_url", prefix: "")
        #expect(result3 == "authURL")

        let result4 = helper.convertToCamelCase("ios_app_icon_name", prefix: "")
        #expect(result4 == "iosAppIconName")
    }

    @Test("CamelCase handles URL suffix correctly")
    func testURLSuffixHandling() throws {
        let helper = TestHelper()

        let result1 = helper.convertToCamelCase("config_url", prefix: "")
        #expect(result1 == "configURL")

        let result2 = helper.convertToCamelCase("base_url", prefix: "")
        #expect(result2 == "baseURL")

        let result3 = helper.convertToCamelCase("web_url", prefix: "")
        #expect(result3 == "webURL")
    }

    // MARK: - Type Inference Tests

    @Test("Type inference detects URL by name suffix")
    func testTypeInferenceURLDetection() throws {
        let helper = TestHelper()

        let (type1, value1) = helper.inferSwiftType(name: "apiURL", value: "https://api.example.com")
        #expect(type1 == .url)
        #expect(value1 == "https://api.example.com")

        let (type2, value2) = helper.inferSwiftType(name: "baseUrl", value: "https://base.com")
        #expect(type2 == .url)
        #expect(value2 == "https://base.com")
    }

    @Test("Type inference handles different value types")
    func testTypeInference() throws {
        let helper = TestHelper()

        // String
        let (type1, value1) = helper.inferSwiftType(name: "name", value: "test")
        #expect(type1 == .string)
        #expect(value1 == "test")

        // Int
        let (type2, value2) = helper.inferSwiftType(name: "count", value: 42)
        #expect(type2 == .int)
        #expect(value2 == "42")

        // Bool
        let (type3, value3) = helper.inferSwiftType(name: "enabled", value: true)
        #expect(type3 == .bool)
        #expect(value3 == "true")

        // Double (whole number)
        let (type4, value4) = helper.inferSwiftType(name: "timeout", value: 30.0)
        #expect(type4 == .int)
        #expect(value4 == "30")
    }

    // MARK: - Prefix Filtering Tests

    @Test("Filter variables by namespace")
    func testFilterVariables() throws {
        let variables: [String: Any] = [
            "environment_name": "dev",
            "api_url": "https://api.example.com",
            "apps": [
                "bundle_identifier": "com.example.app",
                "display_name": "MyApp",
                "ios": [
                    "app_icon_name": "AppIcon"
                ]
            ],
            "features": [
                "debug_menu": true
            ]
        ]

        let helper = TestHelper()

        // Filter for "apps" namespace (includes nested ios)
        let filtered = helper.filterVariables(variables, prefixes: ["apps"])

        // Should have all from apps namespace (leaf keys only, no namespace prefix)
        #expect(filtered.keys.contains("bundleIdentifier"))
        #expect(filtered.keys.contains("displayName"))
        #expect(filtered.keys.contains("appIconName"))

        // Should not have root-level variables or other namespaces
        #expect(!filtered.keys.contains("environmentName"))
        #expect(!filtered.keys.contains("apiURL"))
        #expect(!filtered.keys.contains("debugMenu"))
    }

    @Test("Filter root-level variables")
    func testFilterRootLevelVariables() throws {
        let variables: [String: Any] = [
            "environment_name": "dev",
            "api_url": "https://api.example.com",
            "apps": [
                "bundle_identifier": "com.example.app"
            ]
        ]

        let helper = TestHelper()

        // Filter for root-level variables
        let filtered = helper.filterVariables(variables, prefixes: ["environment_name", "api_url"])

        // Should have root-level variables
        #expect(filtered.keys.contains("environmentName"))
        #expect(filtered.keys.contains("apiURL"))

        // Should not have namespace variables
        #expect(!filtered.keys.contains("bundleIdentifier"))
    }

    @Test("Flatten nested dictionary keeps only leaf keys")
    func testFlattenDictionary() throws {
        let nested: [String: Any] = [
            "bundle_identifier": "com.example",
            "ios": [
                "icon": "AppIcon"
            ]
        ]

        let helper = TestHelper()
        let flattened = helper.flattenDictionary(nested)

        // Leaf keys are preserved without namespace prefix
        #expect(flattened["bundle_identifier"] as? String == "com.example")
        #expect(flattened["icon"] as? String == "AppIcon")

        // Namespace key should not exist
        #expect(flattened["ios_icon"] == nil)
    }

    @Test("Flatten deeply nested dictionary keeps only leaf keys")
    func testFlattenDeeplyNestedDictionary() throws {
        let nested: [String: Any] = [
            "apps": [
                "ios": [
                    "provision_profile": "Development"
                ],
                "bundle_identifier": "com.example"
            ]
        ]

        let helper = TestHelper()
        let flattened = helper.flattenDictionary(nested)

        // Only leaf keys should exist
        #expect(flattened["provision_profile"] as? String == "Development")
        #expect(flattened["bundle_identifier"] as? String == "com.example")

        // Intermediate keys should not exist
        #expect(flattened["apps_ios_provision_profile"] == nil)
        #expect(flattened["ios_provision_profile"] == nil)
        #expect(flattened["apps_bundle_identifier"] == nil)
    }

    @Test("Flatten dictionary with duplicate leaf keys uses last value")
    func testFlattenDictionaryDuplicateLeafKeys() throws {
        let nested: [String: Any] = [
            "ios": [
                "name": "iOS App"
            ],
            "tvos": [
                "name": "tvOS App"
            ]
        ]

        let helper = TestHelper()
        let flattened = helper.flattenDictionary(nested)

        // Only one "name" key should exist (last one wins due to merge)
        #expect(flattened["name"] != nil)
        // The value depends on dictionary iteration order, but should be one of them
        let name = flattened["name"] as? String
        #expect(name == "iOS App" || name == "tvOS App")
    }

    // MARK: - Integration Tests

    @Test("Base type automatically includes all root-level variables")
    func testBaseTypeAutoIncludesRootLevel() async throws {
        let tempDir = FileManager.default.temporaryDirectory
            .appendingPathComponent("xproject-base-auto-test-\(UUID().uuidString)")
        let tempPath = tempDir.path

        defer {
            try? FileManager.default.removeItem(at: tempDir)
        }

        // Create directory structure
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        try FileManager.default.createDirectory(
            at: tempDir.appendingPathComponent("env"),
            withIntermediateDirectories: true
        )
        try FileManager.default.createDirectory(
            at: tempDir.appendingPathComponent("Generated"),
            withIntermediateDirectories: true
        )

        // Create config.yml with empty prefixes for base type
        let config = """
        targets:
          - name: TestApp
            xcconfig_path: Config
            shared_variables:
              BUNDLE_ID: apps.bundle_identifier

        swift_generation:
          enabled: true
          outputs:
            - path: Generated/EnvironmentService.swift
              prefixes: []  # Empty - should auto-include all root-level
              type: base
        """
        let configURL = tempDir.appendingPathComponent("env/config.yml")
        try config.write(to: configURL, atomically: true, encoding: .utf8)

        // Create environment variables with root-level and namespaces
        let variables: [String: Any] = [
            "environment_name": "test",
            "api_url": "https://api.test.com",
            "app_url_scheme": "myapp-test",
            "apps": [
                "bundle_identifier": "com.test.app"
            ],
            "features": [
                "debug_mode": true
            ]
        ]

        // Generate Swift files
        let service = EnvironmentService()
        try service.generateSwiftFiles(
            environmentName: "test",
            variables: variables,
            workingDirectory: tempPath,
            dryRun: false
        )

        // Verify file was created
        let outputURL = tempDir.appendingPathComponent("Generated/EnvironmentService.swift")
        #expect(FileManager.default.fileExists(atPath: outputURL.path))

        // Read and verify content includes ALL root-level variables
        let content = try String(contentsOf: outputURL, encoding: .utf8)
        #expect(content.contains("public final class EnvironmentService"))
        #expect(content.contains("public let apiURL"))
        #expect(content.contains("public let appURLScheme"))
        #expect(content.contains("public let environmentName"))

        // Should NOT include namespace variables (apps, features)
        #expect(!content.contains("bundleIdentifier"))
        #expect(!content.contains("debugMode"))
    }

    @Test("Generate Swift files with configuration")
    func testGenerateSwiftFiles() async throws {
        let tempDir = FileManager.default.temporaryDirectory
            .appendingPathComponent("xproject-swift-gen-test-\(UUID().uuidString)")
        let tempPath = tempDir.path

        defer {
            try? FileManager.default.removeItem(at: tempDir)
        }

        // Create directory structure
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        try FileManager.default.createDirectory(
            at: tempDir.appendingPathComponent("env"),
            withIntermediateDirectories: true
        )
        try FileManager.default.createDirectory(
            at: tempDir.appendingPathComponent("Generated"),
            withIntermediateDirectories: true
        )

        // Create config.yml
        let config = """
        targets:
          - name: TestApp
            xcconfig_path: Config
            shared_variables:
              BUNDLE_ID: apps.bundle_identifier

        swift_generation:
          enabled: true
          outputs:
            - path: Generated/EnvironmentService.swift
              prefixes: [environment_name, api_url]
              type: base
        """
        let configURL = tempDir.appendingPathComponent("env/config.yml")
        try config.write(to: configURL, atomically: true, encoding: .utf8)

        // Create environment variables with namespaces
        let variables: [String: Any] = [
            "environment_name": "test",
            "api_url": "https://api.test.com",
            "apps": [
                "bundle_identifier": "com.test.app"
            ]
        ]

        // Generate Swift files
        let service = EnvironmentService()
        try service.generateSwiftFiles(
            environmentName: "test",
            variables: variables,
            workingDirectory: tempPath,
            dryRun: false
        )

        // Verify file was created
        let outputURL = tempDir.appendingPathComponent("Generated/EnvironmentService.swift")
        #expect(FileManager.default.fileExists(atPath: outputURL.path))

        // Read and verify content
        let content = try String(contentsOf: outputURL, encoding: .utf8)
        #expect(content.contains("public final class EnvironmentService"))
        // Root-level variables converted to camelCase: "environment_name" -> "environmentName", "api_url" -> "apiURL"
        #expect(content.contains("public let apiURL"))
        #expect(content.contains("public let environmentName"))
    }

    @Test("Generate extension with additional imports from configuration")
    func testGenerateExtensionWithImports() async throws {
        let tempDir = FileManager.default.temporaryDirectory
            .appendingPathComponent("xproject-imports-test-\(UUID().uuidString)")
        let tempPath = tempDir.path

        defer {
            try? FileManager.default.removeItem(at: tempDir)
        }

        // Create directory structure
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        try FileManager.default.createDirectory(
            at: tempDir.appendingPathComponent("env"),
            withIntermediateDirectories: true
        )
        try FileManager.default.createDirectory(
            at: tempDir.appendingPathComponent("Generated"),
            withIntermediateDirectories: true
        )

        // Create config.yml with imports
        let config = """
        targets:
          - name: TestApp
            xcconfig_path: Config
            shared_variables:
              BUNDLE_ID: apps.bundle_identifier

        swift_generation:
          outputs:
            - path: Generated/EnvironmentService+App.swift
              prefixes: [apps]
              type: extension
              imports: [CoreModule, SharedTypes]
        """
        let configURL = tempDir.appendingPathComponent("env/config.yml")
        try config.write(to: configURL, atomically: true, encoding: .utf8)

        // Create environment variables
        let variables: [String: Any] = [
            "apps": [
                "bundle_identifier": "com.test.app"
            ]
        ]

        // Generate Swift files
        let service = EnvironmentService()
        try service.generateSwiftFiles(
            environmentName: "test",
            variables: variables,
            workingDirectory: tempPath,
            dryRun: false
        )

        // Verify file was created
        let outputURL = tempDir.appendingPathComponent("Generated/EnvironmentService+App.swift")
        #expect(FileManager.default.fileExists(atPath: outputURL.path))

        // Read and verify content includes imports
        let content = try String(contentsOf: outputURL, encoding: .utf8)
        #expect(content.contains("extension EnvironmentService"))
        #expect(content.contains("import Foundation"))
        #expect(content.contains("import CoreModule"))
        #expect(content.contains("import SharedTypes"))
        #expect(content.contains("public var bundleIdentifier"))
    }
}

// MARK: - Test Helper

/// Helper class that duplicates private method logic for testing
private struct TestHelper {
    func convertToCamelCase(_ key: String, prefix: String) -> String {
        // Duplicate the logic from EnvironmentService
        let components = key.split(separator: "_").map(String.init)
        guard !components.isEmpty else {
            return key
        }

        var camelCase = components[0].lowercased()
        for component in components.dropFirst() {
            camelCase += component.capitalized
        }

        // Special handling for URL suffix
        camelCase = camelCase.replacingOccurrences(
            of: "Url",
            with: "URL",
            options: [],
            range: camelCase.range(of: "Url")
        )

        return camelCase
    }

    func inferSwiftType(name: String, value: Any) -> (SwiftType, String) {
        // Duplicate the logic from EnvironmentService
        if name.hasSuffix("URL") || name.hasSuffix("Url") {
            if let stringValue = value as? String {
                return (.url, stringValue)
            }
        }

        if let stringValue = value as? String {
            return (.string, stringValue)
        } else if let intValue = value as? Int {
            return (.int, String(intValue))
        } else if let boolValue = value as? Bool {
            return (.bool, boolValue ? "true" : "false")
        } else if let doubleValue = value as? Double {
            if doubleValue.truncatingRemainder(dividingBy: 1) == 0 {
                return (.int, String(Int(doubleValue)))
            }
            return (.string, String(doubleValue))
        }

        return (.string, String(describing: value))
    }

    func filterVariables(_ variables: [String: Any], prefixes: [String]) -> [String: Any] {
        var filtered: [String: Any] = [:]

        for prefix in prefixes {
            if let namespaceDict = variables[prefix] as? [String: Any] {
                // This is a namespace (e.g., "apps", "features")
                let flattened = flattenDictionary(namespaceDict)
                for (key, value) in flattened {
                    let camelKey = convertToCamelCase(key, prefix: "")
                    filtered[camelKey] = value
                }
            } else if let rootValue = variables[prefix] {
                // This is a root-level variable (e.g., "environment_name", "api_url")
                let camelKey = convertToCamelCase(prefix, prefix: "")
                filtered[camelKey] = rootValue
            }
        }

        return filtered
    }

    func flattenDictionary(_ dict: [String: Any]) -> [String: Any] {
        var result: [String: Any] = [:]

        for (key, value) in dict {
            if let nestedDict = value as? [String: Any] {
                let flattened = flattenDictionary(nestedDict)
                result.merge(flattened) { _, new in new }
            } else {
                // Terminal value - use only the leaf key
                result[key] = value
            }
        }

        return result
    }
}
