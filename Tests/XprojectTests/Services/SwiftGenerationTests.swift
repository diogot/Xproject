//
// SwiftGenerationTests.swift
// Xproject
//

import Foundation
import Testing
@testable import Xproject

struct SwiftGenerationTests {
    // MARK: - Template Tests

    @Test("Base class template generates correct Swift code")
    func testBaseClassTemplate() throws {
        let properties = [
            SwiftProperty(name: "apiURL", type: .url, value: "https://api.example.com"),
            SwiftProperty(name: "environmentName", type: .string, value: "development"),
            SwiftProperty(name: "debugMode", type: .bool, value: "true"),
            SwiftProperty(name: "maxRetries", type: .int, value: "3")
        ]

        let output = SwiftTemplates.generateBaseClass(properties: properties, environmentName: "dev")

        #expect(output.contains("public final class EnvironmentService"))
        #expect(output.contains("public init() {}"))
        #expect(output.contains("public let apiURL = url(\"https://api.example.com\")"))
        #expect(output.contains("public let debugMode = true"))
        #expect(output.contains("public let environmentName = \"development\""))
        #expect(output.contains("public let maxRetries = 3"))
        #expect(output.contains("Generated by xp env load dev"))
        #expect(output.contains("private func url(_ urlString: String) -> URL"))
    }

    @Test("Extension template generates correct Swift code")
    func testExtensionTemplate() throws {
        let properties = [
            SwiftProperty(name: "bundleIdentifier", type: .string, value: "com.example.app"),
            SwiftProperty(name: "displayName", type: .string, value: "MyApp")
        ]

        let output = SwiftTemplates.generateExtension(properties: properties, environmentName: "production")

        #expect(output.contains("extension EnvironmentService"))
        #expect(output.contains("public var bundleIdentifier: String { \"com.example.app\" }"))
        #expect(output.contains("public var displayName: String { \"MyApp\" }"))
        #expect(output.contains("Generated by xp env load production"))
    }

    @Test("Extension template includes URL helper only when needed")
    func testExtensionURLHelper() throws {
        let propertiesWithURL = [
            SwiftProperty(name: "apiURL", type: .url, value: "https://api.example.com")
        ]
        let outputWithURL = SwiftTemplates.generateExtension(properties: propertiesWithURL, environmentName: "dev")
        #expect(outputWithURL.contains("private func url"))

        let propertiesWithoutURL = [
            SwiftProperty(name: "name", type: .string, value: "test")
        ]
        let outputWithoutURL = SwiftTemplates.generateExtension(properties: propertiesWithoutURL, environmentName: "dev")
        #expect(!outputWithoutURL.contains("private func url"))
    }

    @Test("Base class template generates additional imports")
    func testBaseClassWithImports() throws {
        let properties = [
            SwiftProperty(name: "name", type: .string, value: "test")
        ]

        let output = SwiftTemplates.generateBaseClass(
            properties: properties,
            environmentName: "dev",
            imports: ["ModuleA", "ModuleB"]
        )

        #expect(output.contains("import Foundation"))
        #expect(output.contains("import ModuleA"))
        #expect(output.contains("import ModuleB"))
        // Verify imports are sorted alphabetically
        let foundationIndex = output.range(of: "import Foundation")!.lowerBound
        let moduleAIndex = output.range(of: "import ModuleA")!.lowerBound
        let moduleBIndex = output.range(of: "import ModuleB")!.lowerBound
        #expect(foundationIndex < moduleAIndex)
        #expect(moduleAIndex < moduleBIndex)
    }

    @Test("Extension template generates additional imports")
    func testExtensionWithImports() throws {
        let properties = [
            SwiftProperty(name: "bundleIdentifier", type: .string, value: "com.example.app")
        ]

        let output = SwiftTemplates.generateExtension(
            properties: properties,
            environmentName: "dev",
            imports: ["CoreModule"]
        )

        #expect(output.contains("import Foundation"))
        #expect(output.contains("import CoreModule"))
        #expect(output.contains("extension EnvironmentService"))
    }

    @Test("Templates without imports only include Foundation")
    func testTemplatesWithoutImports() throws {
        let properties = [
            SwiftProperty(name: "name", type: .string, value: "test")
        ]

        let baseOutput = SwiftTemplates.generateBaseClass(
            properties: properties,
            environmentName: "dev"
        )
        let extensionOutput = SwiftTemplates.generateExtension(
            properties: properties,
            environmentName: "dev"
        )

        // Both should contain Foundation but no other imports
        #expect(baseOutput.contains("import Foundation"))
        #expect(extensionOutput.contains("import Foundation"))

        // Count "import " occurrences - should be exactly 1
        let baseImportCount = baseOutput.components(separatedBy: "import ").count - 1
        let extensionImportCount = extensionOutput.components(separatedBy: "import ").count - 1
        #expect(baseImportCount == 1)
        #expect(extensionImportCount == 1)
    }

    @Test("Templates filter empty strings and duplicates from imports")
    func testTemplatesFilterInvalidImports() throws {
        let properties = [
            SwiftProperty(name: "name", type: .string, value: "test")
        ]

        let output = SwiftTemplates.generateBaseClass(
            properties: properties,
            environmentName: "dev",
            imports: ["ModuleA", "", "ModuleA", "ModuleB", ""]
        )

        // Should contain Foundation and both modules (deduplicated)
        #expect(output.contains("import Foundation"))
        #expect(output.contains("import ModuleA"))
        #expect(output.contains("import ModuleB"))

        // Should NOT contain empty import
        #expect(!output.contains("import \n"))
        #expect(!output.contains("import\n"))

        // Count imports - should be exactly 3 (Foundation, ModuleA, ModuleB)
        let importCount = output.components(separatedBy: "import ").count - 1
        #expect(importCount == 3)
    }

    @Test("Templates reject malicious module names with code injection")
    func testTemplatesRejectCodeInjection() throws {
        let properties = [
            SwiftProperty(name: "name", type: .string, value: "test")
        ]

        // Attempt various code injection attacks
        let maliciousImports = [
            "Foundation\nimport UIKit",           // Newline injection
            "UIKit\n\nclass Malicious {}",        // Code injection via newline
            "Module-Name",                         // Invalid character (hyphen)
            "Module.Submodule",                    // Invalid character (dot)
            "123Module",                           // Starts with digit
            "Module Name",                         // Space in name
            "Module;print(\"hacked\")",           // Semicolon injection
            "_ValidModule",                        // Valid: starts with underscore
            "Valid_Module_123"                     // Valid: underscores and digits
        ]

        let output = SwiftTemplates.generateBaseClass(
            properties: properties,
            environmentName: "dev",
            imports: maliciousImports
        )

        // Should only contain valid modules
        #expect(output.contains("import Foundation"))
        #expect(output.contains("import Valid_Module_123"))
        #expect(output.contains("import _ValidModule"))

        // Should NOT contain any malicious content
        #expect(!output.contains("UIKit"))
        #expect(!output.contains("Malicious"))
        #expect(!output.contains("hacked"))
        #expect(!output.contains("Module-Name"))
        #expect(!output.contains("Module.Submodule"))
        #expect(!output.contains("123Module"))

        // Count imports - should be exactly 3 (Foundation + 2 valid modules)
        let importCount = output.components(separatedBy: "import ").count - 1
        #expect(importCount == 3)
    }

    // MARK: - Integration Tests

    @Test("Base type automatically includes all root-level variables")
    func testBaseTypeAutoIncludesRootLevel() async throws {
        let tempDir = FileManager.default.temporaryDirectory
            .appendingPathComponent("xproject-base-auto-test-\(UUID().uuidString)")
        let tempPath = tempDir.path

        defer {
            try? FileManager.default.removeItem(at: tempDir)
        }

        // Create directory structure
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        try FileManager.default.createDirectory(
            at: tempDir.appendingPathComponent("env"),
            withIntermediateDirectories: true
        )
        try FileManager.default.createDirectory(
            at: tempDir.appendingPathComponent("Generated"),
            withIntermediateDirectories: true
        )

        // Create config.yml with empty prefixes for base type
        let config = """
        targets:
          - name: TestApp
            xcconfig_path: Config
            shared_variables:
              BUNDLE_ID: apps.bundle_identifier

        swift_generation:
          enabled: true
          outputs:
            - path: Generated/EnvironmentService.swift
              prefixes: []  # Empty - should auto-include all root-level
              type: base
        """
        let configURL = tempDir.appendingPathComponent("env/config.yml")
        try config.write(to: configURL, atomically: true, encoding: .utf8)

        // Create environment variables with root-level and namespaces
        let variables: [String: Any] = [
            "environment_name": "test",
            "api_url": "https://api.test.com",
            "app_url_scheme": "myapp-test",
            "apps": [
                "bundle_identifier": "com.test.app"
            ],
            "features": [
                "debug_mode": true
            ]
        ]

        // Generate Swift files
        let service = EnvironmentService()
        try service.generateSwiftFiles(
            environmentName: "test",
            variables: variables,
            workingDirectory: tempPath,
            dryRun: false
        )

        // Verify file was created
        let outputURL = tempDir.appendingPathComponent("Generated/EnvironmentService.swift")
        #expect(FileManager.default.fileExists(atPath: outputURL.path))

        // Read and verify content includes ALL root-level variables
        let content = try String(contentsOf: outputURL, encoding: .utf8)
        #expect(content.contains("public final class EnvironmentService"))
        #expect(content.contains("public let apiURL"))
        #expect(content.contains("public let appURLScheme"))
        #expect(content.contains("public let environmentName"))

        // Should NOT include namespace variables (apps, features)
        #expect(!content.contains("bundleIdentifier"))
        #expect(!content.contains("debugMode"))
    }

    @Test("Generate Swift files with configuration")
    func testGenerateSwiftFiles() async throws {
        let tempDir = FileManager.default.temporaryDirectory
            .appendingPathComponent("xproject-swift-gen-test-\(UUID().uuidString)")
        let tempPath = tempDir.path

        defer {
            try? FileManager.default.removeItem(at: tempDir)
        }

        // Create directory structure
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        try FileManager.default.createDirectory(
            at: tempDir.appendingPathComponent("env"),
            withIntermediateDirectories: true
        )
        try FileManager.default.createDirectory(
            at: tempDir.appendingPathComponent("Generated"),
            withIntermediateDirectories: true
        )

        // Create config.yml
        let config = """
        targets:
          - name: TestApp
            xcconfig_path: Config
            shared_variables:
              BUNDLE_ID: apps.bundle_identifier

        swift_generation:
          enabled: true
          outputs:
            - path: Generated/EnvironmentService.swift
              prefixes: [environment_name, api_url]
              type: base
        """
        let configURL = tempDir.appendingPathComponent("env/config.yml")
        try config.write(to: configURL, atomically: true, encoding: .utf8)

        // Create environment variables with namespaces
        let variables: [String: Any] = [
            "environment_name": "test",
            "api_url": "https://api.test.com",
            "apps": [
                "bundle_identifier": "com.test.app"
            ]
        ]

        // Generate Swift files
        let service = EnvironmentService()
        try service.generateSwiftFiles(
            environmentName: "test",
            variables: variables,
            workingDirectory: tempPath,
            dryRun: false
        )

        // Verify file was created
        let outputURL = tempDir.appendingPathComponent("Generated/EnvironmentService.swift")
        #expect(FileManager.default.fileExists(atPath: outputURL.path))

        // Read and verify content
        let content = try String(contentsOf: outputURL, encoding: .utf8)
        #expect(content.contains("public final class EnvironmentService"))
        // Root-level variables converted to camelCase: "environment_name" -> "environmentName", "api_url" -> "apiURL"
        #expect(content.contains("public let apiURL"))
        #expect(content.contains("public let environmentName"))
    }

    @Test("Generate multiple platform outputs with separate values")
    func testGenerateMultiplePlatformOutputs() async throws {
        let tempDir = FileManager.default.temporaryDirectory
            .appendingPathComponent("xproject-multi-platform-test-\(UUID().uuidString)")
        let tempPath = tempDir.path

        defer {
            try? FileManager.default.removeItem(at: tempDir)
        }

        // Create directory structure
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        try FileManager.default.createDirectory(
            at: tempDir.appendingPathComponent("env"),
            withIntermediateDirectories: true
        )
        try FileManager.default.createDirectory(
            at: tempDir.appendingPathComponent("Generated/MobileApp"),
            withIntermediateDirectories: true
        )
        try FileManager.default.createDirectory(
            at: tempDir.appendingPathComponent("Generated/DesktopApp"),
            withIntermediateDirectories: true
        )

        // Create config.yml with two platform-specific outputs
        // Each platform uses unique key names to avoid conflicts
        let config = """
        targets:
          - name: TestApp
            xcconfig_path: Config
            shared_variables:
              BUNDLE_ID: apps.bundle_identifier

        swift_generation:
          outputs:
            - path: Generated/MobileApp/EnvironmentService.swift
              prefixes: [shared, mobile]
              type: extension
            - path: Generated/DesktopApp/EnvironmentService.swift
              prefixes: [shared, desktop]
              type: extension
        """
        let configURL = tempDir.appendingPathComponent("env/config.yml")
        try config.write(to: configURL, atomically: true, encoding: .utf8)

        // Create environment variables with platform-specific values
        // Use separate top-level namespaces with unique key names per platform
        let variables: [String: Any] = [
            "shared": [
                "bundle_display_name": "TestApp"
            ],
            "mobile": [
                "mobile_bundle_identifier": "com.test.mobile",
                "mobile_config_resource": "mobile_config",
                "mobile_provision_profile": "Mobile Distribution Profile"
            ],
            "desktop": [
                "desktop_bundle_identifier": "com.test.desktop",
                "desktop_config_resource": "desktop_config",
                "desktop_provision_profile": "Desktop Distribution Profile"
            ]
        ]

        // Generate Swift files
        let service = EnvironmentService()

        // Run multiple times to ensure deterministic behavior
        for iteration in 0..<5 {
            try service.generateSwiftFiles(
                environmentName: "test",
                variables: variables,
                workingDirectory: tempPath,
                dryRun: false
            )

            // Verify mobile file was created with MOBILE values
            let mobileURL = tempDir.appendingPathComponent("Generated/MobileApp/EnvironmentService.swift")
            #expect(FileManager.default.fileExists(atPath: mobileURL.path))
            let mobileContent = try String(contentsOf: mobileURL, encoding: .utf8)

            #expect(mobileContent.contains("extension EnvironmentService"), "Iteration \(iteration): Mobile should be extension")
            #expect(mobileContent.contains("bundleDisplayName"), "Iteration \(iteration): Mobile should have shared bundleDisplayName")
            #expect(mobileContent.contains("\"com.test.mobile\""), "Iteration \(iteration): Mobile should have mobile bundle identifier")
            #expect(mobileContent.contains("\"mobile_config\""), "Iteration \(iteration): Mobile should have mobile config resource")
            #expect(mobileContent.contains("\"Mobile Distribution Profile\""), "Iteration \(iteration): Mobile should have mobile provision profile")

            // Verify mobile does NOT contain desktop values
            #expect(!mobileContent.contains("\"com.test.desktop\""), "Iteration \(iteration): Mobile should NOT have desktop bundle identifier")
            #expect(!mobileContent.contains("\"desktop_config\""), "Iteration \(iteration): Mobile should NOT have desktop config resource")
            #expect(!mobileContent.contains("\"Desktop Distribution Profile\""), "Iteration \(iteration): Mobile should NOT have desktop provision profile")

            // Verify desktop file was created with DESKTOP values
            let desktopURL = tempDir.appendingPathComponent("Generated/DesktopApp/EnvironmentService.swift")
            #expect(FileManager.default.fileExists(atPath: desktopURL.path))
            let desktopContent = try String(contentsOf: desktopURL, encoding: .utf8)

            #expect(desktopContent.contains("extension EnvironmentService"), "Iteration \(iteration): Desktop should be extension")
            #expect(desktopContent.contains("bundleDisplayName"), "Iteration \(iteration): Desktop should have shared bundleDisplayName")
            #expect(desktopContent.contains("\"com.test.desktop\""), "Iteration \(iteration): Desktop should have desktop bundle identifier")
            #expect(desktopContent.contains("\"desktop_config\""), "Iteration \(iteration): Desktop should have desktop config resource")
            #expect(desktopContent.contains("\"Desktop Distribution Profile\""), "Iteration \(iteration): Desktop should have desktop provision profile")

            // Verify desktop does NOT contain mobile values
            #expect(!desktopContent.contains("\"com.test.mobile\""), "Iteration \(iteration): Desktop should NOT have mobile bundle identifier")
            #expect(!desktopContent.contains("\"mobile_config\""), "Iteration \(iteration): Desktop should NOT have mobile config resource")
            #expect(!desktopContent.contains("\"Mobile Distribution Profile\""), "Iteration \(iteration): Desktop should NOT have mobile provision profile")
        }
    }

    @Test("Generate extension with additional imports from configuration")
    func testGenerateExtensionWithImports() async throws {
        let tempDir = FileManager.default.temporaryDirectory
            .appendingPathComponent("xproject-imports-test-\(UUID().uuidString)")
        let tempPath = tempDir.path

        defer {
            try? FileManager.default.removeItem(at: tempDir)
        }

        // Create directory structure
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        try FileManager.default.createDirectory(
            at: tempDir.appendingPathComponent("env"),
            withIntermediateDirectories: true
        )
        try FileManager.default.createDirectory(
            at: tempDir.appendingPathComponent("Generated"),
            withIntermediateDirectories: true
        )

        // Create config.yml with imports
        let config = """
        targets:
          - name: TestApp
            xcconfig_path: Config
            shared_variables:
              BUNDLE_ID: apps.bundle_identifier

        swift_generation:
          outputs:
            - path: Generated/EnvironmentService+App.swift
              prefixes: [apps]
              type: extension
              imports: [CoreModule, SharedTypes]
        """
        let configURL = tempDir.appendingPathComponent("env/config.yml")
        try config.write(to: configURL, atomically: true, encoding: .utf8)

        // Create environment variables
        let variables: [String: Any] = [
            "apps": [
                "bundle_identifier": "com.test.app"
            ]
        ]

        // Generate Swift files
        let service = EnvironmentService()
        try service.generateSwiftFiles(
            environmentName: "test",
            variables: variables,
            workingDirectory: tempPath,
            dryRun: false
        )

        // Verify file was created
        let outputURL = tempDir.appendingPathComponent("Generated/EnvironmentService+App.swift")
        #expect(FileManager.default.fileExists(atPath: outputURL.path))

        // Read and verify content includes imports
        let content = try String(contentsOf: outputURL, encoding: .utf8)
        #expect(content.contains("extension EnvironmentService"))
        #expect(content.contains("import Foundation"))
        #expect(content.contains("import CoreModule"))
        #expect(content.contains("import SharedTypes"))
        #expect(content.contains("public var bundleIdentifier"))
    }

    @Test("Type inference and camelCase conversion work correctly end-to-end")
    func testTypeInferenceAndCamelCase() async throws {
        let tempDir = FileManager.default.temporaryDirectory
            .appendingPathComponent("xproject-type-inference-test-\(UUID().uuidString)")
        let tempPath = tempDir.path

        defer {
            try? FileManager.default.removeItem(at: tempDir)
        }

        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        try FileManager.default.createDirectory(
            at: tempDir.appendingPathComponent("env"),
            withIntermediateDirectories: true
        )
        try FileManager.default.createDirectory(
            at: tempDir.appendingPathComponent("Generated"),
            withIntermediateDirectories: true
        )

        let config = """
        targets:
          - name: TestApp
            xcconfig_path: Config
            shared_variables: {}

        swift_generation:
          outputs:
            - path: Generated/Environment.swift
              prefixes: [apps]
              type: extension
        """
        try config.write(
            to: tempDir.appendingPathComponent("env/config.yml"),
            atomically: true,
            encoding: .utf8
        )

        // Variables with various types and naming patterns
        let variables: [String: Any] = [
            "apps": [
                // CamelCase conversion patterns
                "bundle_identifier": "com.example.app",      // → bundleIdentifier
                "ios_app_icon_name": "AppIcon",              // → iosAppIconName
                // URL detection by name suffix
                "api_url": "https://api.example.com",        // → apiURL (URL type)
                "config_url": "https://config.example.com",  // → configURL (URL type)
                "base_url": "https://base.example.com",      // → baseURL (URL type)
                // Type inference from values
                "max_retries": 5,                            // → Int
                "debug_enabled": true,                       // → Bool
                "timeout_seconds": 30.0,                     // → Int (whole number Double)
                // Deep nesting
                "ios": [
                    "provision_profile": "Development"       // → provisionProfile
                ]
            ]
        ]

        let service = EnvironmentService()
        try service.generateSwiftFiles(
            environmentName: "test",
            variables: variables,
            workingDirectory: tempPath,
            dryRun: false
        )

        let content = try String(
            contentsOf: tempDir.appendingPathComponent("Generated/Environment.swift"),
            encoding: .utf8
        )

        // Verify CamelCase conversion
        #expect(content.contains("bundleIdentifier"))
        #expect(content.contains("iosAppIconName"))

        // Verify URL type detection (uses url() helper)
        #expect(content.contains("apiURL"))
        #expect(content.contains("configURL"))
        #expect(content.contains("baseURL"))
        #expect(content.contains("url(\"https://api.example.com\")"))
        #expect(content.contains("url(\"https://config.example.com\")"))

        // Verify type inference
        #expect(content.contains("maxRetries: Int { 5 }"))
        #expect(content.contains("debugEnabled: Bool { true }"))
        #expect(content.contains("timeoutSeconds: Int { 30 }"))

        // Verify deep nesting flattens correctly
        #expect(content.contains("provisionProfile"))
        #expect(content.contains("\"Development\""))
    }

    @Test("Duplicate leaf keys in environment variables throws error")
    func testDuplicateLeafKeysThrowsError() async throws {
        let tempDir = FileManager.default.temporaryDirectory
            .appendingPathComponent("xproject-duplicate-test-\(UUID().uuidString)")
        let tempPath = tempDir.path

        defer {
            try? FileManager.default.removeItem(at: tempDir)
        }

        // Create directory structure
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        try FileManager.default.createDirectory(
            at: tempDir.appendingPathComponent("env"),
            withIntermediateDirectories: true
        )
        try FileManager.default.createDirectory(
            at: tempDir.appendingPathComponent("Generated"),
            withIntermediateDirectories: true
        )

        // Create config.yml that requests both ios and tvos prefixes
        let config = """
        targets:
          - name: TestApp
            xcconfig_path: Config
            shared_variables: {}

        swift_generation:
          outputs:
            - path: Generated/Environment.swift
              prefixes: [ios, tvos]
              type: extension
        """
        let configURL = tempDir.appendingPathComponent("env/config.yml")
        try config.write(to: configURL, atomically: true, encoding: .utf8)

        // Create variables with duplicate leaf keys across namespaces
        let variables: [String: Any] = [
            "ios": [
                "app_name": "iOS App",
                "bundle_id": "com.example.ios"
            ],
            "tvos": [
                "app_name": "tvOS App",  // Duplicate key!
                "bundle_id": "com.example.tvos"  // Duplicate key!
            ]
        ]

        let service = EnvironmentService()

        // Should throw duplicateLeafKey error
        do {
            try service.generateSwiftFiles(
                environmentName: "test",
                variables: variables,
                workingDirectory: tempPath,
                dryRun: false
            )
            Issue.record("Expected duplicateLeafKey error to be thrown")
        } catch let error as EnvironmentError {
            if case let .duplicateLeafKey(key, namespaces) = error {
                // Should catch one of the duplicate keys (app_name or bundle_id)
                #expect(key == "app_name" || key == "bundle_id")
                #expect(namespaces.count == 2)
            } else {
                Issue.record("Expected duplicateLeafKey error, got \(error)")
            }
        }
    }
}
