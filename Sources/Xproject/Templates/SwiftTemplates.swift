//
// SwiftTemplates.swift
// Xproject
//

import Foundation

/// Embedded Swift code templates for environment code generation
public enum SwiftTemplates {
    /// Generate a base EnvironmentService class
    /// - Parameters:
    ///   - properties: Array of property definitions
    ///   - environmentName: Name of the environment
    ///   - imports: Additional module imports
    /// - Returns: Swift source code
    public static func generateBaseClass(
        properties: [SwiftProperty],
        environmentName: String,
        imports: [String] = []
    ) -> String {
        let additionalImports = imports.sorted().map { "import \($0)" }.joined(separator: "\n")
        let importsSection = additionalImports.isEmpty ? "" : "\n\(additionalImports)"

        var output = """
        //
        // EnvironmentService.swift
        // Generated by xp env load \(environmentName)
        // DO NOT EDIT - This file is auto-generated
        //

        import Foundation\(importsSection)

        public final class EnvironmentService {
            public init() {}


        """

        for property in properties.sorted(by: { $0.name < $1.name }) {
            output += generateProperty(property)
        }

        output += """
        }

        """

        // Add helper function if any URL types
        if properties.contains(where: { $0.type == .url }) {
            output += """

            private func url(_ urlString: String) -> URL {
                // swiftlint:disable:next force_unwrapping
                return URL(string: urlString)!
            }

            """
        }

        return output
    }

    /// Generate an extension to EnvironmentService
    /// - Parameters:
    ///   - properties: Array of property definitions
    ///   - environmentName: Name of the environment
    ///   - imports: Additional module imports
    /// - Returns: Swift source code
    public static func generateExtension(
        properties: [SwiftProperty],
        environmentName: String,
        imports: [String] = []
    ) -> String {
        let additionalImports = imports.sorted().map { "import \($0)" }.joined(separator: "\n")
        let importsSection = additionalImports.isEmpty ? "" : "\n\(additionalImports)"

        var output = """
        //
        // EnvironmentService+Extension.swift
        // Generated by xp env load \(environmentName)
        // DO NOT EDIT - This file is auto-generated
        //

        import Foundation\(importsSection)

        extension EnvironmentService {

        """

        for property in properties.sorted(by: { $0.name < $1.name }) {
            output += generateComputedProperty(property)
        }

        output += """
        }

        """

        // Add helper function if any URL types
        if properties.contains(where: { $0.type == .url }) {
            output += """

            private func url(_ urlString: String) -> URL {
                // swiftlint:disable:next force_unwrapping
                return URL(string: urlString)!
            }

            """
        }

        return output
    }

    // MARK: - Private Helpers

    private static func generateProperty(_ property: SwiftProperty) -> String {
        let value = formatValue(property)
        return "    public let \(property.name) = \(value)\n"
    }

    private static func generateComputedProperty(_ property: SwiftProperty) -> String {
        let value = formatValue(property)
        return "    public var \(property.name): \(property.type.rawValue) { \(value) }\n"
    }

    private static func formatValue(_ property: SwiftProperty) -> String {
        switch property.type {
        case .string:
            return "\"\(property.value)\""
        case .url:
            return "url(\"\(property.value)\")"
        case .int:
            return property.value
        case .bool:
            return property.value
        }
    }
}

/// Represents a Swift property to be generated
public struct SwiftProperty: Sendable {
    public let name: String
    public let type: SwiftType
    public let value: String

    public init(name: String, type: SwiftType, value: String) {
        self.name = name
        self.type = type
        self.value = value
    }
}

/// Swift type for generated properties
public enum SwiftType: String, Sendable {
    case string = "String"
    case url = "URL"
    case int = "Int"
    case bool = "Bool"
}
