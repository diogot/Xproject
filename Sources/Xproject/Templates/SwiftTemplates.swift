//
// SwiftTemplates.swift
// Xproject
//

import Foundation

/// Embedded Swift code templates for environment code generation
public enum SwiftTemplates {
    // Valid Swift module name pattern: starts with letter or underscore, followed by letters, digits, or underscores
    // swiftlint:disable:next force_try
    private static let validModuleNamePattern = try! NSRegularExpression(pattern: "^[A-Za-z_][A-Za-z0-9_]*$")

    /// Validates and sanitizes import module names
    /// - Parameter imports: Raw import strings from configuration
    /// - Returns: Validated module names (invalid names are filtered out with warnings)
    private static func sanitizeImports(_ imports: [String]) -> [String] {
        var validImports: [String] = []
        var seen = Set<String>()

        for moduleName in imports {
            // Skip empty strings
            guard !moduleName.isEmpty else { continue }

            // Skip duplicates
            guard !seen.contains(moduleName) else { continue }
            seen.insert(moduleName)

            // Validate module name matches Swift identifier pattern
            let range = NSRange(moduleName.startIndex..., in: moduleName)
            if validModuleNamePattern.firstMatch(in: moduleName, range: range) != nil {
                validImports.append(moduleName)
            } else {
                print("warning: Invalid module name '\(moduleName)' in imports - must match pattern [A-Za-z_][A-Za-z0-9_]*, skipping")
            }
        }

        return validImports.sorted()
    }

    /// Generate a base EnvironmentService class
    /// - Parameters:
    ///   - properties: Array of property definitions
    ///   - environmentName: Name of the environment
    ///   - imports: Additional module imports
    /// - Returns: Swift source code
    public static func generateBaseClass(
        properties: [SwiftProperty],
        environmentName: String,
        imports: [String] = []
    ) -> String {
        let validatedImports = sanitizeImports(imports)
        let additionalImports = validatedImports
            .map { "import \($0)" }
            .joined(separator: "\n")
        let importsSection = additionalImports.isEmpty ? "" : "\n\(additionalImports)"

        var output = """
        //
        // EnvironmentService.swift
        // Generated by xp env load \(environmentName)
        // DO NOT EDIT - This file is auto-generated
        //

        import Foundation\(importsSection)

        public final class EnvironmentService {
            public init() {}


        """

        for property in properties.sorted(by: { $0.name < $1.name }) {
            output += generateProperty(property)
        }

        output += """
        }

        """

        // Add helper function if any URL types
        if properties.contains(where: { $0.type == .url }) {
            output += """

            private func url(_ urlString: String) -> URL {
                // swiftlint:disable:next force_unwrapping
                return URL(string: urlString)!
            }

            """
        }

        return output
    }

    /// Generate an extension to EnvironmentService
    /// - Parameters:
    ///   - properties: Array of property definitions
    ///   - environmentName: Name of the environment
    ///   - imports: Additional module imports
    /// - Returns: Swift source code
    public static func generateExtension(
        properties: [SwiftProperty],
        environmentName: String,
        imports: [String] = []
    ) -> String {
        let validatedImports = sanitizeImports(imports)
        let additionalImports = validatedImports
            .map { "import \($0)" }
            .joined(separator: "\n")
        let importsSection = additionalImports.isEmpty ? "" : "\n\(additionalImports)"

        var output = """
        //
        // EnvironmentService+Extension.swift
        // Generated by xp env load \(environmentName)
        // DO NOT EDIT - This file is auto-generated
        //

        import Foundation\(importsSection)

        extension EnvironmentService {

        """

        for property in properties.sorted(by: { $0.name < $1.name }) {
            output += generateComputedProperty(property)
        }

        output += """
        }

        """

        // Add helper function if any URL types
        if properties.contains(where: { $0.type == .url }) {
            output += """

            private func url(_ urlString: String) -> URL {
                // swiftlint:disable:next force_unwrapping
                return URL(string: urlString)!
            }

            """
        }

        return output
    }

    // MARK: - Private Helpers

    private static func generateProperty(_ property: SwiftProperty) -> String {
        let value = formatValue(property)
        return "    public let \(property.name) = \(value)\n"
    }

    private static func generateComputedProperty(_ property: SwiftProperty) -> String {
        let value = formatValue(property)
        return "    public var \(property.name): \(property.type.rawValue) { \(value) }\n"
    }

    private static func formatValue(_ property: SwiftProperty) -> String {
        switch property.type {
        case .string:
            return "\"\(property.value)\""
        case .url:
            return "url(\"\(property.value)\")"
        case .int:
            return property.value
        case .bool:
            return property.value
        }
    }
}

/// Represents a Swift property to be generated
public struct SwiftProperty: Sendable {
    public let name: String
    public let type: SwiftType
    public let value: String

    public init(name: String, type: SwiftType, value: String) {
        self.name = name
        self.type = type
        self.value = value
    }
}

/// Swift type for generated properties
public enum SwiftType: String, Sendable {
    case string = "String"
    case url = "URL"
    case int = "Int"
    case bool = "Bool"
}
