//
// AppKeysTemplate.swift
// Xproject
//
// Template for generating obfuscated AppKeys Swift code from secrets
//

import Foundation

/// Template for generating AppKeys class with obfuscated secrets
public enum AppKeysTemplate {
    /// Generate an AppKeys class with obfuscated secrets
    ///
    /// This generates a Swift class where secrets are stored as obfuscated byte arrays
    /// instead of plaintext strings. This prevents secrets from being extracted with
    /// the `strings` command.
    ///
    /// - Parameters:
    ///   - secrets: Dictionary of secret key-value pairs
    ///   - prefixes: Prefixes to filter secrets (e.g., ["all", "ios"])
    ///   - environment: Name of the environment (for header comment)
    /// - Returns: Swift source code
    public static func generateAppKeys(
        secrets: [String: String],
        prefixes: [String],
        environment: String
    ) -> String {
        // Filter secrets by prefix
        let filteredSecrets = filterSecretsByPrefix(secrets, prefixes: prefixes)

        // Generate obfuscated properties
        let properties = filteredSecrets.map { key, value in
            ObfuscatedProperty(
                originalKey: key,
                propertyName: convertToPropertyName(key),
                obfuscatedBytes: StringObfuscator.obfuscate(value)
            )
        }.sorted { $0.propertyName < $1.propertyName }

        // Generate the Swift code
        var output = generateHeader(environment: environment, prefixes: prefixes)
        output += generateClassStart()
        output += generateObfuscatedProperties(properties)
        output += generateComputedProperties(properties)
        output += generateClassEnd()
        output += generateDeobfuscationExtension()

        return output
    }

    // MARK: - Header Generation

    private static func generateHeader(environment: String, prefixes: [String]) -> String {
        """
        //
        // AppKeys.swift
        // Generated by xp secrets generate \(environment)
        // DO NOT EDIT - This file is auto-generated
        //
        // Secrets are obfuscated using XOR to prevent extraction with `strings` command.
        // Prefixes: \(prefixes.joined(separator: ", "))
        //

        import Foundation


        """
    }

    // MARK: - Class Structure

    private static func generateClassStart() -> String {
        """
        /// Application secrets (obfuscated)
        ///
        /// Secrets are stored as obfuscated byte arrays and deobfuscated at runtime.
        /// This prevents them from appearing as plaintext strings in the compiled binary.
        public final class AppKeys {
            private init() {} // Prevent instantiation


        """
    }

    private static func generateObfuscatedProperties(_ properties: [ObfuscatedProperty]) -> String {
        guard !properties.isEmpty else {
            return ""
        }

        var output = "    // MARK: - Obfuscated Storage\n\n"

        for property in properties {
            let bytesString = formatByteArray(property.obfuscatedBytes)
            output += "    private static let _\(property.propertyName): [UInt8] = \(bytesString)\n"
        }

        output += "\n"
        return output
    }

    private static func generateComputedProperties(_ properties: [ObfuscatedProperty]) -> String {
        guard !properties.isEmpty else {
            return ""
        }

        var output = "    // MARK: - Public Accessors\n\n"

        for property in properties {
            output += """
                /// Secret key: \(property.originalKey)
                public static var \(property.propertyName): String {
                    // swiftlint:disable:next force_unwrapping
                    return String(bytes: _\(property.propertyName).deobfuscated, encoding: .utf8)!
                }


            """
        }

        return output
    }

    private static func generateClassEnd() -> String {
        """
        }


        """
    }

    // MARK: - Deobfuscation Extension

    private static func generateDeobfuscationExtension() -> String {
        """
        // MARK: - Deobfuscation

        private extension Array where Element == UInt8 {
            /// Deobfuscates a byte array that was obfuscated using XOR
            ///
            /// Splits the array in half and XORs the two halves together to recover
            /// the original bytes.
            var deobfuscated: [UInt8] {
                guard count > 0, count % 2 == 0 else {
                    return []
                }

                let halfCount = count / 2
                let xoredHalf = prefix(halfCount)
                let keyHalf = suffix(halfCount)

                // XOR the two halves to recover original bytes
                return zip(xoredHalf, keyHalf).map(^)
            }
        }

        """
    }

    // MARK: - Helper Functions

    /// Filter secrets by prefix
    ///
    /// Keeps secrets that start with any of the specified prefixes (e.g., "all_", "ios_").
    /// If prefixes is empty, returns all secrets.
    private static func filterSecretsByPrefix(_ secrets: [String: String], prefixes: [String]) -> [String: String] {
        guard !prefixes.isEmpty else {
            return secrets
        }

        return secrets.filter { key, _ in
            prefixes.contains { prefix in
                key.hasPrefix("\(prefix)_")
            }
        }
    }

    /// Convert a secret key to a Swift property name
    ///
    /// Examples:
    /// - `all_api_key` → `apiKey`
    /// - `ios_shopify_api_url` → `shopifyAPIURL`
    /// - `services_mux_key` → `muxKey`
    private static func convertToPropertyName(_ key: String) -> String {
        // Remove prefix (all_, ios_, tvos_, services_, etc.)
        let withoutPrefix: String
        if let underscoreIndex = key.firstIndex(of: "_") {
            withoutPrefix = String(key[key.index(after: underscoreIndex)...])
        } else {
            withoutPrefix = key
        }

        // Convert to camelCase
        let components = withoutPrefix.split(separator: "_").map(String.init)

        guard !components.isEmpty else {
            return ""
        }

        // First component lowercase, rest capitalized
        var result = components[0].lowercased()

        for component in components.dropFirst() {
            // Check if component is URL-like suffix
            if component.uppercased() == "URL" || component.uppercased() == "URI" || component.uppercased() == "API" {
                result += component.uppercased()
            } else {
                result += component.capitalized
            }
        }

        return result
    }

    /// Format byte array for Swift code
    ///
    /// Formats the byte array with reasonable line wrapping for readability.
    private static func formatByteArray(_ bytes: [UInt8]) -> String {
        let bytesPerLine = 16
        var result = "["

        for (index, byte) in bytes.enumerated() {
            if index > 0 {
                result += ", "
            }

            if index > 0 && index % bytesPerLine == 0 {
                result += "\n        "
            }

            result += "\(byte)"
        }

        result += "]"
        return result
    }
}

// MARK: - Supporting Types

/// Represents an obfuscated secret property
private struct ObfuscatedProperty {
    let originalKey: String
    let propertyName: String
    let obfuscatedBytes: [UInt8]
}
